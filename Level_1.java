import java.util.*;
public class Level_1 {
    public static void main(String[] args) {
        //int[] arr={19,13,12,27,4,6,1};
        // isprime_approch_1(arr);
        // isprime_approch_2(arr);
        // All_Prime();
        // int n=5;
        // Fibo_Approch_1(n);
        // for(int i=0;i<n;i++){
        //     System.out.println("v "+Fibo_Approch_2(i));
        // }
        //Count_Digit(12345);
        // Print_Digit(1234500);
        //Reverse_Number(12345);
        //Invere_Number(21453);
        // Rotate_Number(12345,6);
        // GCD_LCM();
        // prime_factorization(13);
        // Pythogoron_triplet(5,3,4);
        // Benjamin_bulb();
        // Pattern_1(5);
        // Pattern_2(5);
        // Pattern_3(5);
        // Pattern_4(5);
        // Pattern_5(5);
        // Pattern_6(5);
        // Pattern_7(5);
        // Pattern_8(5);
        // Pattern_9(5);
        // Pattern_10(5);
        // Pattern_11(5);
        // Pattern_12(5);
        // Pattern_13(5);
        // Pattern_14(5);
        // Pattern_15(5);
        // Digit_Frequency(1234533,5);
        // Decimal_To_Any_Base(634, 8);
        // Any_Base_To_Decimal(1111, 2);
        // Any_Base_To_Any_Base();
        // Any_Base_Add(346, 777, 8);
        // Any_Base_Subtract(236, 1212, 8);//n2>n1
        // Any_Base_Multiply(2,2,8);
        // Span_Array();
        // Linear_Search(arr,10);
        // Bar_Chart();
        // Sum_Of_Two_Array();
        // Difference_Of_Two_Array();
        // Duplicate_Brackets();
        // Balance_Bracket();
        // Next_Big_Element();
        // Stock_Span();
        // Largest_Area();
        // Sliding_Window_Max();
        // Sliding_Window_Max_2(arr,4);
        // Celebrity_Problem();
        // Megre_Overlapping();//not completed

        //LINKED LIST
        //LINKED LIST
        //LINKED LIST
        //LINKED LIST
        //LINKED LIST

        // LinkedList list = new LinkedList();
    // list.addLast(10);list.addLast(20);list.addLast(30);list.addLast(23);
    //list.addLast(40);list.addLast(50);list.addLast(60);list.addLast(70);

     //list.addFirst(2);
     //list.display();
    // list.addAt(2,11);
    // list.display();
    // list.RemoveFirst();
    // list.display();
    // list.RemoveLast();
    // list.display();
    // list.RemoveAt(3);
    // list.display();
    //  System.out.println(list.getLast()+"--"+list.getFirst());
    //  System.out.println(list.getAt(2));
    //  System.out.print("\n"+"Size = "+ list.size());
    // System.out.println(list.kthfromlast(2));
    // list.RevereDI(); list.display();
    // System.out.println(list.kthfromlast(2));
    //System.out.println(list.mid());
    //   LinkedList list = new LinkedList();
    // list.addLast(10);list.addLast(20);list.addLast(30);list.addLast(23);
    //   LinkedList list2 = new LinkedList();
    // list2.addLast(11);list2.addLast(2);list2.addLast(0);list2.addLast(3);
    // LinkedList ans=Merg(list,list2);
    // ans.display();
    LinkedList list = new LinkedList();
    list.addLast(1);
    list.addLast(2);
    list.addLast(30);
    list.addLast(4);
    list.addLast(41);
    list.addLast(13);
    list.addLast(21);
    list.addLast(111);
    // list.display();
    // list.RemoveDuplicate();
    // list.display();
    // list.oddeven();
    // list.display();
    // list.DisplayReverse();
    // list.reversePR();
    // list.display();
    // System.out.println(list.isplain());
    // list.fold();
    // list.display();
    // list.Add(list,list2);
    //     //intersection is not working 
    // int nn=list.intersection(list,list2);
    // System.out.println(nn);
    // list.Krevferse(3);
    // list.display();

    list.reverseDR();
    list.display();

        //       RECURSION
        //       RECURSION
        //       RECURSION
        //       RECURSION
        //       RECURSION
        //       RECURSION
               //int n=5;
        // printincreasin(n);
        // printdecreasing(n);
        // printd_i(n);
        // System.out.println(fact(n));
        // System.out.println(power_liner(n, 3));
        //zigzag(n);
        //tower_of_hanoi(n,100,200,300);
        //int[] arr={11,2,3,4,2,1,2};
        // display_array(arr, 0);
        //display_array_rev(arr, 0);
        //System.out.println(max_in_arr(arr, 0));
        //System.out.println(first_index(arr,0,2));
        //System.out.println(last_index(arr, 0, 2));
        // int[] ans=all_index(arr, 2, 0, 0);
        // for(int k:ans)System.out.println(k);
        // ArrayList<String> ans=get_subsequence("abc");
        // System.out.println(ans);
        // ArrayList<String> ans=getkpc("678");
        // System.out.println(ans);
        // ArrayList<String> ans=stair_path(4);
        // System.out.println(ans);
        // ArrayList<String> ans=maze_path(1,1,3, 3);
        // System.out.println(ans);
        // ArrayList<String> ans=get_all_maze_path(1,1,3, 3);
        // System.out.println(ans);
        //print_subsequence("abc","");
        //print_stair_path(4,"");
        // print_maze_path(1, 1, 3, 3, "");
        //print_maze_path_with_jump(1, 1, 3, 3, "");
        //print_permutation("abc","");
        //print_encoding("123","");
        // int[][] arr1={
        //     {0,1,1,0},
        //     {0,0,1,0},
        //     {1,0,0,1},
        //     {0,1,0,0},
        // };
        // boolean[][] visited=new boolean[arr1.length][arr1[0].length];
        // flood_fill(arr1,0,0,"",visited);
        // int[] arr3={10,20,30,40,50};
        // int target=50;
        // tartget_sum_subset(arr3,0,"",0,target);
        // int[][] arr=new int[4][4];
        // N_Queens(arr, "", 0);


    }
    public static void isprime_approch_1(int[] arr){
        //this is approch 1
        for(int i=0;i<arr.length;i++){
            int count=0;
            for(int div=1;div<=arr[i];div++){
                if(arr[i]%div==0){
                    count++;
                }
            }
            if(count==2){
                System.out.println("Prime");
            }else{
                System.out.println("Not Prime");
            }
        }
    }
    public static void isprime_approch_2(int[] arr){
        for(int i=0;i<arr.length;i++){
            int count=0;
            for(int div=2;div*div<=arr[i];div++){
                if(arr[i]%div==0){
                    count++;
                    break;
                }
            }
            if(count==0){
                System.out.println("Prime");
            }else{
                System.out.println("Not Prime");
            }
        }
    }
    public static void All_Prime(){
        //print all prime between two range
        Scanner scn=new Scanner(System.in);
        int low=scn.nextInt();
        int high=scn.nextInt();

        for(int i=low;i<=high;i++){
            int count=0;
            for(int div=2;div*div<=i;div++){
                if(i%div==0){
                    count++;
                    break;
                }
            }
            if(count==0){
                System.out.println(i);
            }
        }
        scn.close();
    }
    public static void Fibo_Approch_1(int n){
        int f=0,s=1,t;
        for(int i=0;i<n;i++){
            System.out.println(f);//0 1 1 2 3
            t=f+s;//1 2 3
            f=s;//1 1 2
            s=t;//1 2 3
        }
    }
    public static int Fibo_Approch_2(int n){
        if(n==0)return 0;
        if(n==1)return 1;

        int f=Fibo_Approch_2(n-1)+Fibo_Approch_2(n-2);
        return f;
    }
    public static void Count_Digit(int n){
        int count=0;
        while(n!=0){
            n/=10;
            count++;
        }
        System.out.println(count);
    }
    public static void Print_Digit(int n){
        //print digit from starting 
        int number_of_digit=0;
        int temp=n;
        while(temp!=0){
            temp/=10;
            number_of_digit++;
        }
        int div=(int)Math.pow(10,number_of_digit-1);
        while(div!=0){
            int q=n/div;
            System.out.println(q);
            n=n%div;
            div/=10;
        }
    }
    public static void Reverse_Number(int n){
        int n1=n;
        while(n>0){
            int t=n%10;
            n=n/10;
            System.out.println(t);
        }
        int rv=0;
        while(n1!=0){
            int last=n1%10;
            rv=rv*10+last;
            n1/=10;
        }
        System.out.println(rv);
    }
    public static void Invere_Number(int n){ 
        int inv=0;
        int op=1;
        while(n!=0){
            int od=n%10;
            int id=op;
            int ip=od;

            inv=inv+id*(int)Math.pow(10,ip-1);
            n/=10;
            op++;
        }
        System.out.println(inv);
    }
    public static void Rotate_Number(int n,int k){
        int temp=n;
        int nod=0;
        while(temp>0){
            temp/=10;
            nod++;
        }
        k=k%nod;
        if(k<0){
            k=k+nod;
        }
        int div=1;
        int mult=1;
        for(int i=1;i<=nod;i++){
            if(i<=k){
                div=div*10;
            }else{
                mult=mult*10;
            }
        }
        int q=n/div;
        int r=n%div;

        int rot=r*mult+q;
        System.out.println(rot);
    }
    public static void GCD_LCM(){
        Scanner sc=new Scanner(System.in);
        int n1=sc.nextInt();
        int n2=sc.nextInt();
        int on1=n1;
        int on2=n2;
        while(n1%n2!=0){
            int rem=n1%n2;
            n1=n2;
            n2=rem;
        }
        int gcd=n2;
        int lcm=(on1*on2)/gcd;
        System.out.println(gcd);
        System.out.println(lcm);
        sc.close();
    }
    public static void prime_factorization(int n){
        //print prime factor till n
        for(int div=2;div*div<=n;div++){
            while(n%div==0){
                n=n/div;
                System.out.println(div);
            }
        }
        if(n!=1){
            System.out.println(n);
        }
    }
    public static void Pythogoron_triplet(int a,int b,int c){
        int max=a;
        if(b>=max){
            max=b;
        }
        if(c>=max){
            max=c;
        }
        if(max==a){
            boolean flag=((b*b+c*c)==(a*a));
            System.out.println(flag);
        }else if(max==b){
            boolean flag=((a*a+c*c)==(b*b));
            System.out.println(flag);
        }else{
            boolean flag=((b*b+a*a)==(c*c));
            System.out.println(flag);
        }
    }
    public static void Benjamin_bulb(){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();//print perfect square of given number
        for(int i=1;i*i<=n;i++){
            System.out.println(i*i);
        }
        sc.close();
    }
    public static void Pattern_1(int n){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                System.out.print("*");
            }
            System.out.println();
        }
    }
    public static void Pattern_2(int n){
        for(int i=n;i>=1;i--){
            for(int j=1;j<=i;j++){
                System.out.print("*");
            }
            System.out.println();
        }
    }
    public static void Pattern_3(int n){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(j>=(n+1)-i){
                    System.out.print("*");
                }else{
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    public static void Pattern_4(int n){
        int sp=n-1;
        int st=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=sp;j++){
                System.out.print(" ");
            }
            for(int j=1;j<=st;j++){
                System.out.print("*");
            }
            sp--;st++;
            System.out.println();
        }
    }
    public static void Pattern_5(int n){
        int sp=0;
        int st=n;
        for(int i=1;i<=n;i++){
            //System.out.println(sp+" "+st);
            for(int j=1;j<=sp;j++){
                System.out.print(" ");
            }
            for(int j=1;j<=st;j++){
                System.out.print("*");
            }
            sp++;
            st--;
            System.out.println();
        }
    }
    public static void Pattern_6(int n){
        int sp=n/2;
        int st=1;
        for(int i=1;i<=n;i++){
            //System.out.println(sp+" "+st);
            for(int j=1;j<=sp;j++){
                System.out.print(" ");
            }
            for(int j=1;j<=st;j++){
                System.out.print("*");
            }
            if(i<=n/2){
                sp--;st+=2;
            }else{
                sp++;
                st-=2;
            }
            System.out.println();
        }
    }
    public static void Pattern_7(int n){
        int st=n/2+1;
        int sp=1;
        for(int i=1;i<=n;i++){
            //System.out.println(st+" "+sp+" "+st);
            for(int j=1;j<=st;j++){
                System.out.print("*");
            }
            for(int j=1;j<=sp;j++){
                System.out.print(" ");
            }
            for(int j=1;j<=st;j++){
                System.out.print("*");
            }
            if(i<=n/2){
                st--;
                sp+=2;
            }else{
                st++;
                sp-=2;
            }
            System.out.println();
        }
    }
    public static void Pattern_8(int n){
        for(int j=1;j<=n;j++){
            for(int i=1;i<=n;i++){
                if(i==j){
                    System.out.print("*");
                }else{
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    public static void Pattern_9(int n){
        //opposite dignol
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i+j==n+1){
                    System.out.print("*");
                }else{
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    public static void Pattern_10(int n){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i==j||i+j==n+1){
                    System.out.print("*");
                }else{
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    public static void Pattern_11(int n){
        int osp=n/2;
        int isp=-1;
        for(int i=1;i<=n;i++){
            //System.out.println(osp+"-"+isp);
            for(int j=1;j<=osp;j++){
                System.out.print(" ");
            }
            System.out.print("*");
            for(int j=1;j<=isp;j++){
                System.out.print(" ");
            }
            if(i>1&&i<n){
                System.out.print("*");
            }
            if(i<=n/2){
                osp--;
                isp+=2;
            }else{
                osp++;
                isp-=2;
            }
            System.out.println();
        }
    }
    public static void Pattern_12(int n){
        int v=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                System.out.print(v+++" ");
            }
            System.out.println();
        }
    }
    public static void Pattern_13(int n){
        int a=0,b=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                System.out.print(a+"  ");
                int c=a+b;
                a=b;
                b=c;
            }
            System.out.println();
        }
    }
    public static void Pattern_14(int n){
        for(int i=0;i<n;i++){
            int icj=1;
            for(int j=0;j<=i;j++){
                System.out.print("\t"+icj);
                int icjp1=icj*(i-j)/(j+1);
                icj=icjp1;
            }
            System.out.println();
        }
    }
    public static void Pattern_15(int n){
        for(int i=1;i<=10;i++){
            int val=n*i;
            System.out.println(n+"X"+i+"="+val);
        }
    }
    public static void Digit_Frequency(int n,int digit){
        int count=0;
        while(n!=0){
            int last=n%10;
            if(last==digit){
                count++;
            }
            n/=10;
        }
        System.out.println(count);
    }
    public static void Decimal_To_Any_Base(int n,int b){
        int rv=0;
        int p=1;
        while(n>0){
            int dig=n%b;
            n=n/b;

            rv+=dig*p;
            p=p*10;
        }
        System.out.println(rv);
    }
    public static void Any_Base_To_Decimal(int n,int b){
        int rv=0;
        int p=1;
        while(n>0){
            int dig=n%10;
            n=n/10;

            rv+=dig*p;
            p=p*b;
        }
        System.out.println(rv);
    }
    //ANY BASE TO ANY BASE START HERE
    public static void Any_Base_To_Any_Base(){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int b1=sc.nextInt();
        int b2=sc.nextInt();
        int dec=Any_base_to_Decimal(n, b1);
        int ans=Decimal_to_any_base(dec, b2);
        System.out.println(ans);
        sc.close();
    }
    public static int Any_base_to_Decimal(int n,int b){
        int rv=0;
        int p=1;
        while(n>0){
            int dig=n%10;
            n=n/10;

            rv+=dig*p;
            p=p*b;
        }
        return rv;
    }
    public static int Decimal_to_any_base(int n,int b) {
        int rv=0;
        int p=1;
        while(n>0){
            int dig=n%b;
            n=n/b;

            rv+=dig*p;
            p=p*10;
        }
        return rv;
    }
    // END
    public static void Any_Base_Add(int n1,int n2,int b){
        int rv=0;
        int c=0;
        int p=1;
        while(n1>0||n2>0||c>0){
            int d1=n1%10;
            int d2=n2%10;
            n1=n1/10;
            n2=n2/10;

            int d=d1+d2+c;
            c=d/b;
            d=d%b;
            rv+=d*p;
            p=p*10;
        }
        System.out.println(rv);
    }
    public static void Any_Base_Subtract(int n1,int n2,int b){
        int rv=0;
        int c=0;
        int p=1;
        while(n2>0){
            int d1=n1%10;
            n1=n1/10;
            int d2=n2%10;
            n2=n2/10;

            int d=0;
            d2=d2+c;

            if(d2>=d1){
                c=0;
                d=d2-d1;
            }else{
                c=-1;
                d=d2+b-d1;
            }
            rv=rv+d*p;
            p=p*10;
        }
        System.out.println(rv);
    }
    //multiply start
    public static void Any_Base_Multiply(int n1,int n2,int b){
        int rv=0;
        int p=1;
        while(n2>0){
            int d2=n2%10;
            n2=n2/10;
    
            int spr=multiply_with_single_digit(n1, d2, b);
            rv=Add( spr*p,rv, b);
            p=p*10;
        }
        System.out.println(rv);
    }
    static int multiply_with_single_digit(int n1,int d2,int b){
        int rv=0;
        int p=1;
        int c=0;
        while(n1>0||c>0){
            int d1=n1%10;
            n1=n1/10;

            int d=d1*d2+c;
            c=d/b;
            d=d%b;

            rv=rv+d*p;
            p=p*10;
        }
        return rv;
    }
    public static int Add(int n1,int n2,int b) {
        int rv=0;

        int c=0;
        int p=1;
        while(n1>0||n2>0||c>0){
            int d1=n1%10;
            int d2=n2%10;
            n1=n1/10;
            n2=n2/10;

            int d=d1+d2+c;
            c=d/b;
            d=d%b;
            rv+=d*p;
            p=p*10;
        }
        return rv;
    }
    //multiply end
    public static void Span_Array(){
        Scanner sc=new Scanner(System.in);
        int array_size=sc.nextInt();
        int[] arr=new int[array_size];
        for(int i=0;i<array_size;i++){
            arr[i]=sc.nextInt();
        }

        int max=arr[0];
        int min=arr[0];
        for(int i=0;i<arr.length;i++){
            if(arr[i]>max){
                max=arr[i];
            }
            if(arr[i]<min){
                min=arr[i];
            }
        }
        System.out.println(max-min);
        sc.close();
    }
    public static void Linear_Search(int[] arr,int key){
        int ans=-1;
        for(int i=0;i<arr.length;i++){
            if(arr[i]==key){
                ans=i;
                break;
            }
        }
        System.out.println("Index="+ans);
    }
    public static void Bar_Chart(){
        Scanner sc=new Scanner(System.in);
        int array_size=sc.nextInt();
        int[] arr=new int[array_size];
        for(int i=0;i<array_size;i++){
            arr[i]=sc.nextInt();
        }
        int max=arr[0];
        for(int i=0;i<arr.length;i++){
            if(arr[i]>max){
                max=arr[i];
            }
        }
        for(int floor=max;floor>=1;floor--){
            for(int i=0;i<arr.length;i++){
                if(arr[i]>=floor){
                    System.out.print("*");
                }else{
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
        sc.close();
    }
    public static void Sum_Of_Two_Array(){
        Scanner sc=new Scanner(System.in);
        int n1=sc.nextInt();
        int n2=sc.nextInt();
        int[] arr1=new int[n1];
        int[] arr2=new int[n2];
        for(int i=0;i<n1;i++){
            arr1[i]=sc.nextInt();
        }
        for(int i=0;i<n2;i++){
            arr2[i]=sc.nextInt();
        }
        int[] sum=new int[n1>n2?n1:n2];
        int c=0;

        int i=arr1.length-1;
        int j=arr2.length-1;
        int k=sum.length-1;

        while(k>=0){
            int d=c;

            if(i>=0){
                d+=arr1[i];
            }
            if(j>=0){
                d+=arr2[j];
            }
            c=d/10;
            d=d%10;
            sum[k]=d;
            i--;j--;k--;
        }
        if(c!=0){
            System.out.print(c);
        }
        for(int val:sum){
            System.out.print(val);
        }
        sc.close();
    }
    public static void Difference_Of_Two_Array(){
        Scanner sc=new Scanner(System.in);
        int n1=sc.nextInt();
        int arr1[]=new int[n1];//n1>n2
        for(int i=0;i<arr1.length;i++){
            arr1[i]=sc.nextInt();
        }
        int n2=sc.nextInt();
        int arr2[]=new int[n2];
        for(int i=0;i<arr2.length;i++){
            arr2[i]=sc.nextInt();
        }
        int[] diff=new int[n2];
        int c=0;
        int i=arr1.length-1;
        int j=arr2.length-1;
        int k=diff.length-1;

        while(k>=0){
            int d=0;
            int aiv=i>=0?arr1[i]:0;
            if(arr2[j]+c>=aiv){
                d=arr2[j]+c-aiv;
                c=0;
            }else{
                d=arr2[j]+c+10-aiv;
                c=-1;
            }
            diff[k]=d;

            i--;j--;k--;
        }
        int indx=0;
        while(indx<diff.length){
            if(diff[indx]==0){
                indx++;
            }else{
                break;
            }
        }
        while(indx<diff.length){
            System.out.print(diff[indx]);
            indx++;
        }
        sc.close();
    }
    public static void Duplicate_Brackets(){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        sc.close();
        Stack<Character> s=new Stack<>();
        for(int i=0;i<str.length();i++){
            char ch=str.charAt(i);
            if(ch==')'){
                if(s.peek()=='('){
                    System.out.println("Duplicate");
                    return;
                }else{
                    while(s.peek()!='('){
                        s.pop();
                    }
                }
            }else{
                s.push(ch);
            }
        }
        System.out.println("No Duplicate");
    }
    public static void Balance_Bracket(){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();

        Stack<Character> st=new Stack<>();
        for(int i=0;i<str.length();i++){
            char ch=str.charAt(i);
            if(ch=='('||ch=='{'||ch=='['){
                st.push(ch);
            }else if(ch==')'){
                boolean val=handle(st, '(');
                if(val==false){
                    System.out.println(val);
                    return;
                }
            }else if(ch=='}'){
                boolean val=handle(st, '{');
                if(val==false){
                    System.out.println(val);
                    return;
                }
            }else if(ch==']'){
                boolean val=handle(st, '[');
                if(val==false){
                    System.out.println(val);
                    return;
                }
            }else{

            }
        }
        if(st.size()==0){
            System.out.println("True");
        }else{
            System.out.println("False");
        }
        sc.close();
    }
    public static boolean handle(Stack<Character> st,char corr) {
        if(st.size()==0){
            return false;
        }else if(st.peek()!=corr){
            return false;
        }else{
            st.pop();
            return true;
        }
    }
    //balance bracket end
    public static void Next_Big_Element(){
        Scanner sc=new Scanner(System.in);
        int n1=sc.nextInt();
        int[] arr=new int[n1];
        for(int i=0;i<arr.length;i++){
            arr[i]=sc.nextInt();
        }
        //
        int[] nge=new int[arr.length];
        Stack<Integer> st=new Stack<>();
        st.push(arr[arr.length-1]);
        nge[arr.length-1]=-1;

        for(int i=arr.length-2;i>=0;i--){
            //-a+
            while(st.size()>0&&arr[i]>=st.peek()){
                st.pop();
            }
            if(st.size()==0){
                nge[i]=-1;
            }else{
                nge[i]=st.peek();
            }
            st.push(arr[i]);
        }
        for(int k:nge){
            System.out.print(k+"  ");
        }
        sc.close();
    }
    public static void Stock_Span(){
        Scanner sc=new Scanner(System.in);
        int arrsize=sc.nextInt();
        int[] arr=new int[arrsize];
        for(int i=0;i<arr.length;i++){
            arr[i]=sc.nextInt();
        }
        //logic start
        int[] span=new int[arr.length];

        Stack<Integer> st=new Stack<>();
        st.push(0);
        span[0]=1;

        for(int i=1;i<arr.length;i++){
            while(st.size()>0&&arr[i]>arr[st.peek()]){
                st.pop();
            }
            if(st.size()==0){
                span[i]=i+1;
            }else{
                span[i]=i-st.peek();
            }
            st.push(i);
        }
        for(int h:span){
            System.out.print(h+" ");
        }
        sc.close();
    }
    public static void Largest_Area(){
        //largest area in histogram
        Scanner sc=new Scanner(System.in);
        int arrsize=sc.nextInt();
        int[] arr=new int[arrsize];
        for(int i=0;i<arr.length;i++){
            arr[i]=sc.nextInt();
        }
        //next greater element index on the right
        int[] rb=new int[arr.length];
        Stack<Integer> st;
        st=new Stack<>();
        st.push(arr.length-1);
        rb[arr.length-1]=arr.length;
        for(int i=arr.length-2;i>=0;i--){
            while(st.size()>0&&arr[i]<arr[st.peek()]){
                st.pop();
            }
            if(st.size()==0){
                rb[i]=arr.length;
            }else{
                rb[i]=st.peek();
            }
            st.push(i);
        }
        //next greater element index on the left
        int[] lb=new int[arr.length];
        st=new Stack<>();
        st.push(0);
        lb[0]=-1;
        for(int i=1;i<arr.length;i++){
            while(st.size()>0&&arr[i]<arr[st.peek()]){
                st.pop();
            }
            if(st.size()==0){
                lb[i]=-1;
            }else{
                lb[i]=st.peek();
            }
            st.push(i);
        }

        int maxarea=0;
        for(int i=0;i<arr.length;i++){
            int width=rb[i]-lb[i]-1;
            int area=arr[i]*width;
            if(area>maxarea){
                maxarea=area;
            }
        }
        System.out.println("Area"+maxarea);
        sc.close();
    }
    public static void Sliding_Window_Max(){
        //find max in every window like k=4
        //input=1,2,3,4,5,6
        //output=4 5 6
        Scanner sc=new Scanner(System.in);
        int arrsize=sc.nextInt();
        int[] arr=new int[arrsize];
        for(int i=0;i<arr.length;i++){
            arr[i]=sc.nextInt();
        }
        int k=4;
        Stack<Integer> st=new Stack<>();
        int[] nge=new int[arr.length];
        st.push(arr.length-1);
        nge[arr.length-1]=arr.length;
        for(int i=arr.length-2;i>=0;i--){
            //pop answer push
            while(st.size()>0&&arr[i]>=arr[st.peek()]){
                st.pop();
            }
            if(st.size()==0){
                nge[i]=arr.length;
            }else{
                nge[i]=st.peek();
            }
            st.push(i);
        }
        for(int i=0;i<=arr.length-k;i++){
            int j=i;
            while(nge[j]<i+k){
                j=nge[j];
            }
            System.out.print(arr[j]+"-");
        }
    }
    public static void Sliding_Window_Max_2(int[] arr,int k){
        //find max in window size
        //IP={1,22,3,41,15,46,57,18,29}
        //OP=41-41-46-57-57-57-
        int max=0;
        for(int i=0;i<=arr.length-k;i++){
            max=0;
            int l=i;
            for(int j=i;j<k+l;j++){
                if(max<arr[j]){
                    max=arr[j];
                }
            }
            System.out.print(max+"-");
        }
    }
    public static void Celebrity_Problem(){
        int[] arr={0,1,2,3};//T C=Big O N
        int[][] mat={
            {0,1,1,1},
            {1,0,1,0},
            {0,0,1,0},
            {1,1,1,0},
        };
        Stack<Integer> st=new Stack<>();
        for(int i=0;i<arr.length;i++){
            st.push(arr[i]);
        }

        while(st.size()>=2){
            int i=st.pop();
            int j=st.pop();
            if(mat[i][j]==1){
                st.push(j);
            }else{
                st.push(i);
            }
        }
        int pot=st.pop();
        for(int i=0;i<mat.length;i++){
            if(i!=pot){
                if(mat[i][pot]==0||mat[pot][i]==1){
                    System.out.println("None");
                    return;
                }
            }
        }
        System.out.println(pot);
    }
    public static void Megre_Overlapping(){
        //merge overlapping intervel
        // class pair{
        //     int st;
        //     int et;
        //     pair(int st,int et){
        //         this.st=st;
        //         this.et=et;
        //     }
        // }
    }
    
    //LINKEDLIST
    //LINKEDLIST
    //LINKEDLIST
    //LINKEDLIST
    //LINKEDLIST
    //LINKEDLIST

    static class Node {
        int data;
        Node next;
        }
        static class LinkedList {
        Node head;
        Node tail;
        int size;
        int getFirst(){
            if(size==0){
                System.out.println("List Empty");
                return -1;
            }else{
                return head.data;
            }
        }
        int getLast(){
            if(size==0){
                System.out.println("List Empty");
                return -1;
            }else{
                return tail.data;
            }
        }
        int getAt(int index){
            if(size==0){
                System.out.println("List Empty");
                return -1;
            }else if(index<0||index>=size){
                System.out.println("Invalid ");
                return -1;
            }else{
                Node temp=head;
                for(int i=0;i<index;i++){
                    temp=temp.next;
                }
                return temp.data;
            }
        }
        void RemoveAt(int index){
            if(index<0||index>=size){
                System.out.println("Invalid");
            }else if(index==0){
                RemoveFirst();
            }else{
                Node temp=head;
                for(int i=0;i<index-1;i++){
                    temp=temp.next;
                }
                temp.next=temp.next.next;
                size--;
            } 
        }
        void RemoveLast(){
            if(size==0){
                System.out.println("List is Empty");
            }else if(size==1){
                head=tail=null;
                size=0;
            }else{
                Node temp=head;
                for(int i=0;i<size-2;i++){
                    temp=temp.next;
                }
                tail=temp;
                temp.next=null;
                size--;
            } 
        }
        void RemoveFirst(){
            if(size==0){
                System.out.println("List is Empty");
            }else if(size==1){
                head=tail=null;
                size=0;
            }else{
                head=head.next;
                size--;
            }
        }
        void addAt(int index,int value){
            if(index<0||index>size){
                System.out.println("Invalid argument");
            }else if(index==size){
                addLast(value);
            }else{
                Node node=new Node();
                node.data=value;
                Node temp=head;
                for(int i=0;i<index-1;i++){
        temp=temp.next;
        }
        node.next=temp.next;
        temp.next=node;
        size++;
            }
        }
        void addFirst(int val){
            Node temp=new Node();
            temp.data=val;
            temp.next=head;
            head=temp;
            if(size==0)tail=temp;
            size++;
        }
        void addLast(int val) {
            Node temp = new Node();
            temp.data = val;
            temp.next = null;
    
            if (size == 0) {
                head = tail = temp;
            } else {
            tail.next = temp;
            tail = temp;
            }
            size++;
        }
        public int size(){
            return size;
        }
        public void display(){
            Node temp=head;
        while(temp!=null){
            System.out.print(temp.data+"--");
            temp=temp.next;
        }
        System.out.println("Null");
        }
        public  void RevereDI(){
            int li=0;
            int ri=size-1;
            while(li<ri){
                Node left=getNodeAt(li);
                Node right=getNodeAt(ri);
                int temp=left.data;
                left.data=right.data;
                right.data=temp;
                li++;ri--;
            }
        }
        Node getNodeAt(int index){
            Node temp=head;
            for(int i=0;i<index;i++){
                temp=temp.next;
            }
            return temp;
        }
        int kthfromlast(int k){
            //Reverse list through iterative 
            Node s=head;
            Node f=head;
            for(int i=0;i<k;i++){
                f=f.next;
            }
            while(f!=tail){
                s=s.next;
                f=f.next;
            }
            return s.data;
        }
        int mid(){
            Node s=head;
            Node f=head;
            while(f.next!=null&&f.next.next!=null){
                s=s.next;
                f=f.next.next;
            }
            return s.data;
        }
        //this merg and merg sort not work see it
        LinkedList Merg(Node l1,Node l2){
            Node one=l1;
            Node two=l2;
            LinkedList res=new LinkedList();
            while(one!=null&&two!=null){
                if(one.data<two.data){
                    res.addLast(one.data);
                    one=one.next;
                }else{
                    res.addLast(two.data);
                    two=two.next;
                }
            }
            while(one!=null){
                res.addLast(one.data);
                    one=one.next;
            }
            while(two!=null){
                res.addLast(two.data);
                two=two.next;
            }
            return res;
        }
        public void RemoveDuplicate(){
            LinkedList res=new LinkedList();
            while(this.size()>0){
                int val=this.getFirst();
                this.RemoveFirst();
                if(res.size()==0||res.tail.data!=val){
                    res.addLast(val);
                }
            }
            this.head=res.head;
            this.tail=res.tail;
            this.size=res.size;
        }
        public void oddeven(){
            LinkedList odd=new LinkedList();
            LinkedList even=new LinkedList();
            while(this.size()>0){
                int val=this.getFirst();
                this.RemoveFirst();
                if(val%2==0){
                    even.addLast(val);
                }else{
                    odd.addLast(val);
                }
            }
            
            if(odd.size>0&&even.size>0){
                this.head=odd.head;
                this.tail=even.tail;
                this.size=odd.size+even.size;
            }else if(odd.size>0){
                this.head=odd.head;
                this.tail=odd.tail;
                this.size=odd.size;
            }else if(even.size>0){
                this.head=even.head;
                this.tail=even.tail;
                this.size=even.size;
            }
            odd.display();
            even.display();
        }
        public void DisplayReverse(){
            displayreversehelp(head);
            System.out.println();
        }
        public void  displayreversehelp(Node node){
            if(node==null){
                return;
            }
            displayreversehelp(node.next);
            System.out.print(node.data+"--");
        }
        public void reversePR(){
            reversePRhelp(head);
            head.next=null;
            Node temp=head;
            head=tail;
            tail=temp;
        }
        void reversePRhelp(Node node){
            if(node==null)return;
            reversePRhelp(node.next);
            if(node==tail){
                //do noting
            }else{
                node.next.next=node;
            }
        }
        boolean isplain(){
            pleft=head;
            return isplainhelp(head);
        }
        Node pleft;
        boolean isplainhelp(Node right){
            if(right==null)return true;
            boolean rres=isplainhelp(right.next);
            if(rres==false){
                return false;
            }else if(pleft.data!=right.data){
                return false;
            }else{
                pleft=pleft.next;
                return true;
            }
        }
        Node fleft;
        public void fold(){
            fleft=head;
            foldhelp(head,0);
        }
        void foldhelp(Node right,int floor){
            if(right==null)return;
            foldhelp(right.next,floor+1);
            if(floor>size/2){
                Node temp=fleft.next;
                fleft.next=right;
                right.next=temp;
                fleft=temp;
            }else if(floor==size/2){
                tail=right;
                tail.next=null;
            }
        }
        public void Add(LinkedList one,LinkedList two){
            LinkedList res=new LinkedList();
            int oc=addhelp(one.head,one.size,two.head,two.size,res);
            if(oc>0){
                res.addFirst(oc);
            }
            res.display();
            //return res;
        }
        int addhelp(Node one,int pv1,Node two,int pv2,LinkedList res){
            if(one==null&&two==null)return 0;
                
            int data=0;
            if(pv1>pv2){
                int oc=addhelp(one.next,pv1-1,two,pv2,res);
                data=one.data+oc;
            }else if(pv1<pv2){
                int oc=addhelp(one,pv1,two.next,pv2-1,res);
                data=two.data+oc;
            }else{
                int oc=addhelp(one.next,pv1-1,two.next,pv2-1,res);
                data=one.data+two.data+oc;
            }
            int nd=data%10;
            int nc=data/10;
            res.addFirst(nd);
            return nc;
        }
        int intersection(LinkedList one,LinkedList two){
            Node t1=one.head;
            Node t2=two.head;
            
            int delta =Math.abs(one.size-two.size);
            if(one.size>two.size){
                for(int i=0;i<delta;i++){
                    t1=t1.next;
                }
            }else{
                for(int i=0;i<delta;i++){
                    t2=t2.next;
                }
            }
            while(t1!=t2){
                t1=t1.next;
                t2=t2.next;
            }
            return t2.data;
        }
        void Krevferse(int k){
            LinkedList prev=null;
            
            while(this.size>0){
                LinkedList curr=new LinkedList();
                if(this.size>=k){
                    for(int i=0;i<k;i++){
                        int val=this.getFirst();
                        this.RemoveFirst();
                        curr.addFirst(val);
                    }
                }else {
                    int os=this.size();
                    for(int i=0;i<os;i++){
                        int val=this.getFirst();
                        this.RemoveFirst();
                        curr.addFirst(val);
                    }
                }
                if(prev==null){
                    prev=curr;
                }else{
                    prev.tail.next=curr.head;
                    prev.tail=curr.tail;
                    prev.size=curr.size;
                }
            }
            this.head=prev.head;
            this.tail=prev.tail;
            this.size=prev.size;
        }
        Node rleft;
        public void reverseDR(){
            rleft=head;
            reverseDRhelp(head,0);
        }
        public void reverseDRhelp(Node right,int floor){
            if(right==null)return;
            
            reverseDRhelp(right.next,floor+1);
            if(floor>=size/2){
                int temp=right.data;
                right.data=rleft.data;
                rleft.data=temp;
                
                rleft=rleft.next;
                }
            }
        }
        
    
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..
    //2 D  ----    ARRAY..

    public static void multiply2d(){
        Scanner sc=new Scanner(System.in);
        int r=sc.nextInt();
        int c=sc.nextInt();
        int[][] arr=new int[r][c];
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                arr[i][j]=sc.nextInt();
            }
        }
        int r2=sc.nextInt();
        int c2=sc.nextInt();
        int[][] arr2=new int[r2][c2];
        for(int i=0;i<r2;i++){
            for(int j=0;j<c2;j++){
                arr2[i][j]=sc.nextInt();
            }
        }
        if(c!=r2){
            System.out.println("Invalid input");
            return;
        }
        int[][] prd=new int[r][c2];
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                for(int k=0;k<c;k++){
                    prd[i][j]+=arr[i][k]*arr2[k][j];
                }
            }
        }
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                System.out.print(prd[i][j]+"-");
            }
            System.out.println();
        }
    }
    public static void wavetravel(){
        Scanner sc=new Scanner(System.in);
        int r=sc.nextInt();
        int c=sc.nextInt();
        int[][] arr=new int[r][c];
        for(int i=0;i<r;i++){
            for(int j=0;j<c;j++){
                arr[i][j]=sc.nextInt();
            }
        }
        for(int j=0;j<arr[0].length;j++){
            if(j%2==0){
                for(int i=0;i<arr.length;i++){
                    System.out.println(arr[i][j]);
                }
            }else{
                for(int i=arr.length-1;i>=0;i--){
                    System.out.println(arr[i][j]);
                }
            }
        }
    }




    public static void exitpoint(int[][] arr){
	    int dir=0;
	    int i=0,j=0;
	    while(true){
	        dir=(dir+arr[i][j])%4;
	        if(dir==0){//east
	            j++;
	        }else if(dir==1){
	            i++;
	        }else if(dir==3){
	            j--;
	        }else if(dir==4){
	            i--;
	        }
	        if(i<0){
	           i++;
	           break;
	        }else if(j<0){
	            j++;
	            break;
	        }else if(i==arr.length){
	            i--;
	            break;
	        }else if(j==arr[0].length){
	            j--;
	            break;
	        }
	    }
	    System.out.println(i+"-"+j);
	}
	public static void rotate90deg(int[][] arr){
	    for(int i=0;i<arr.length;i++){
	        for(int j=i;j<arr[0].length;j++){
	            int temp=arr[i][j];
	            arr[i][j]=arr[j][i];
	            arr[j][i]=temp;
	        }
	    }
	    for(int i=0;i<arr.length;i++){
	        int li=0;
	        int ri=arr[i].length-1;
	        while(li<ri){
	            int t=arr[i][li];
	            arr[i][li]=arr[i][ri];
	            arr[i][ri]=t;
	            li++;ri--;
	        }
	    }
	    //Display(arr);
	}
	public static void shellrotate(int[][] arr){
        int shell=2;
        int rt=3;
        //int[] oned=fillonedfromshell(arr,shell,rt);
        //rotate(oned,rt);
        //fillshell(arr,shell,oned);
	}
	static int[] fillshellformoned(int[][] arr,int r){
	    int[] ans=new int[4];
	    return ans;
	}
	static void rotate(int[] oned,int r){
	    r=r%oned.length;
	    if(r<0){
	        r=r+oned.length;
	    }
	    reverse(oned,0,oned.length-r-1);
	    reverse(oned,oned.length-1-r,oned.length-1);
	    reverse(oned,0,oned.length-1);
	}
	static void reverse(int[] arr,int li,int ri){
	    while(li<ri){
	        int temp=arr[li];
	        arr[li]=arr[ri];
	        arr[ri]=temp;
	        li++;
	        ri--;
	    }
	}
	static void Diagnoltravel(int[][] arr){
	    
	}
	static void shaddlepoint(int[][] arr){
	    //smallest in row and max in col
	    for(int i=0;i<arr.length;i++){
	        int svj=0;
	        for(int j=1;j<arr[0].length;j++){
	            if(arr[i][j]<arr[i][svj]){
	                svj=j;
	            }
	        }
	        boolean flag=true;
	        for(int k=0;k<arr.length;k++){
	            if(arr[k][svj]>arr[i][svj]){
	                flag=true;
	                break;
	            }
	        }
	        if(flag==true){
	            System.out.println(arr[i][svj]);
	            return;
	        }
	    }
	    System.out.println("Invalid input");
	}
	static void search2Darray(int[][] arr,int data){
	    //search in 2d sorted array
	    int i=0;
	    int j=arr[0].length-1;
	    while(i<arr.length&&j>=0){
	        if(data==arr[i][j]){
	            System.out.println(i+"-"+j);
	            return;
	        }else if(data<arr[i][j]){
	            j--;
	        }else{
	            i++;
	        }
	    }
	}
	static void reversearray(int[] arr){
	    int i=0;
	    int j=arr.length-1;
	    while(i<j){
	        int t=arr[i];
	        arr[i]=arr[j];
	        arr[j]=t;
	        
	        i++;j--;
	    }
	}
	static void rotatearray(int[] arr,int r){
	    r=r%arr.length;
	    if(r<0){
	        r=r+arr.length;
	    }
	    reverse(arr,0,arr.length-r-1);
	    reverse(arr,arr.length-r,arr.length-1);
	    reverse(arr,0,arr.length-1);
	}
	static void inversearray(int[] arr){
	    int[] ans=new int[arr.length];
	    for(int i=0;i<arr.length;i++){
	        int v=arr[i];
	        ans[v]=i;
	    }
	    for(int n:ans){
	        System.out.print(n+" ");
	    }
	}
	static void allsubarray(int[] arr){
	    
	}
    static void Allsubset(int[] arr){
		int limit=(int)Math.pow(2,arr.length);
		for(int i=0;i<arr.length;i++){
			String set="";
			int t=i;
			for(int j=arr.length-1;j>=0;j--){
				int r=t%2;
				t=t/10;
				if(r==0){
					set="-"+set;
				}else{
					set=arr[j]+set;
				}
			}
			System.out.println(set);
		}
	}
	static int Binarysearch(int[] arr,int key){
		int lo=0;
		int hi=arr.length-1;
		while(lo<hi){
			int mid=(hi-lo)/2;
			if(arr[mid]==key){
				return arr[mid];
			}else if(arr[mid]<key){
				lo=mid+1;
			}else{
				hi=mid-1;
			}
		}
		return -1;
	}
	static void ceilandfloor2(int[] arr,int data){
		int ceil=Integer.MIN_VALUE;
		int floor=Integer.MAX_VALUE;
		int lo=0;
		int hi=arr.length-1;
		while(lo<hi){
			int mid=(lo+hi)/2;
			if(data<arr[mid]){
				hi=mid-1;
				ceil=arr[mid];
			}else if(data>arr[mid]){
				lo=mid+1;
				floor=arr[mid];
			}else{
				ceil=arr[mid];
				floor=arr[mid];
				break;
			}
		}
		System.out.println(ceil);
		System.out.println(floor);
	}
	public static int[] searchRange(int[] arr, int target) {
    	int[] ans={-1,-1};
      	if(arr.length==0)return ans; 
        int low=0;
        int high=arr.length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(arr[mid]==target){
                ans[0]=mid;
                high=mid-1;
            }else if(arr[mid]<target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        /////////////
        low=0;
        high=arr.length-1;
        while(low<=high){
            int mid=(low+high)/2;
            if(arr[mid]==target){
                ans[1]=mid;
                low=mid+1;;
            }else if(arr[mid]<target){
                low=mid+1;
            }else{
                high=mid-1;
            }
        }
        return ans;
    }
	public static void Firstandlastindex(int[] arr,int data){
		int lo=0;
		int hi=arr.length-1;
		int fi=-1;
		while(lo<=hi){
			int mid=(lo+hi)/2;
			if(data>arr[mid]){
				lo=mid+1;
			}else if(data<arr[mid]){
				hi=mid-1;
			}else{
				fi=mid;
				hi=mid-1;
			}
		}
		System.out.println(fi);

		 lo=0;
		 hi=arr.length-1;
		 int li=-1;
		while(lo<=hi){
			int mid=(lo+hi)/2;
			if(data>arr[mid]){
				lo=mid+1;
			}else if(data<arr[mid]){
				hi=mid-1;
			}else{
				li=mid;
				lo=mid-1;
			}
		}
		System.out.println(li);
	}

    //RECURSION
    //RECURSION
    //RECURSION
    //RECURSION
    //RECURSION

    static void Knights_tour(){
        
    }
    static void N_Queens(int[][] chess,String qsf,int row){
        if(row==chess.length){
            System.out.println(qsf+".");
            return;
        }
        for(int col=0;col<chess.length;col++){
            if(issafe(chess,row,col)==true){
                chess[row][col]=1;
                N_Queens(chess, qsf+row+"-"+col, row+1);
                chess[row][col]=0;
            }
        }
    }
    static boolean issafe(int[][] chess,int row,int col){
        for(int i=row-1,j=col;i>=0;i--){
            if(chess[i][j]==1){
                return false;
            }
        }
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
            if(chess[i][j]==1){
                return false;
            }
        }
        for(int i=row-1,j=col+1;i>=0&&j<chess.length;i--,j++){
            if(chess[i][j]==1){
                return false;
            }
        }
        return true;
    }
    static void tartget_sum_subset(int[] arr,int index,String set,int sum_of_set,int tar){
        // output 10,40,
        // 20,30,
        // 50,
        if(index==arr.length){
            if(sum_of_set==tar){
                System.out.println(set+"");
            }
            return;
        }
        tartget_sum_subset(arr, index+1, set+arr[index]+",", sum_of_set+arr[index], tar);
        tartget_sum_subset(arr, index+1,set,sum_of_set,tar);
    }
    static void flood_fill(int[][] maze,int row,int col,String psf,boolean[][] visited){
        //rassta from 0,0 cell to last cell in 2d matrix with obstacle 1
        if(row<0||col<0||row==maze.length||col==maze[0].length||maze[row][col]==1||visited[row][col]==true){
            return;
        }
        if(row==maze.length-1&&col==maze[0].length-1){
            System.out.println(psf);
            return;
        }
        visited[row][col]=true;
        flood_fill(maze, row-1, col, psf+"t",visited);
        flood_fill(maze, row, col-1, psf+"l",visited);
        flood_fill(maze, row+1, col, psf+"d",visited);
        flood_fill(maze, row, col+1, psf+"r",visited);
    }
    static void print_encoding(String str,String asf){
        if(str.length()==0){
            System.out.println(asf);
            return;
        }else if(str.length()==1){
            char ch=str.charAt(0);
            if(ch=='0'){
                return;
            }else{
                int chv=ch-'0';
                char code=(char)('a'+chv-1);
                asf=asf+code;
                System.out.println(asf);
            }
        }else{
            char ch=str.charAt(0);
            String ros=str.substring(1);
            if(ch=='0'){
                return;
            }else{
                int chv=ch-'0';
                char code=(char)('a'+chv-1);
                print_encoding(ros,asf+code);
            }
            String ch12=str.substring(0, 2);
            String roq12=str.substring(2);

            int ch12v=Integer.parseInt(ch12);
            if(ch12v<=26){
                char code=(char)('a'+ch12v-1);
                print_encoding(roq12,asf+code);
            }
        }
    }
    static void print_permutation(String str,String ans){
        //output=abc-acb-bac-bca-cab-cba-
        if(str.length()==0){
            System.out.print(ans+"-");
            return;
        }
        for(int i=0;i<str.length();i++){
            char ch=str.charAt(i);
            String leftpart=str.substring(0, i);
            String rightpart=str.substring(i+1);
            String ros=leftpart+rightpart;
            print_permutation(ros, ans+ch);
        }
    }
    static void print_maze_path_with_jump(int sr,int sc,int dr,int dc,String psf){
        if(sr==dr&&sc==dc){
            System.out.println(psf);
            return;
        }
        for(int ms=1;ms<=dc-sc;ms++){
            print_maze_path_with_jump(sr, sc+ms, dr, dc, psf+"h"+ms);
        }
        for(int ms=1;ms<=dr-sr;ms++){
            print_maze_path_with_jump(sr+ms, sc, dr, dc, psf+"v"+ms);
        }
        for(int ms=1;ms<=dc-sc&&ms<=dr-sr;ms++){
            print_maze_path_with_jump(sr+ms, sc+ms, dr, dc, psf+"d"+ms);
        }
    }
    static void print_maze_path(int sr,int sc,int dr,int dc,String psf){
        if(sr>dr||sc>dc){
            return;
        }
        if(sr==dr&&sc==dc){
            System.out.println(psf);
            return;
        }
        print_maze_path(sr, sc+1, dr, dc, psf+"h");
        print_maze_path(sr+1, sc, dr, dc, psf+"v");
    }
    static void print_stair_path(int n,String path){
        if(n<0){
            return;
        }
        if(n==0){
            System.out.println(path);
            return;
        }
        print_stair_path(n-1, path+"1");
        print_stair_path(n-2, path+"2");
        print_stair_path(n-3, path+"3");
    }
    static void print_subsequence(String que,String ans){
        if(que.length()==0){
            System.out.println(ans);
            return;
        }
        char ch=que.charAt(0);
        String roq=que.substring(1);

        print_subsequence(roq, ans+"");
        print_subsequence(roq, ans+ch);
    }
    static ArrayList<String> get_all_maze_path(int sr,int sc,int dr,int dc){
        //get all path in 2D matrix with all jump possible
        if(sr==dr&&sc==dc){
            ArrayList<String> o=new ArrayList<>();
            o.add("");
            return o;
        }
        ArrayList<String> path=new ArrayList<>();
        //horizontal
        for(int h=1;h<=dc-sc;h++){
            ArrayList<String> hpath=get_all_maze_path(sr, sc+h, dr, dc);
            for(String hpat:hpath){
                path.add("h"+h+hpat);
            }
        }
        //vertiacl
        for(int h=1;h<=dr-sr;h++){
            ArrayList<String> vpath=get_all_maze_path(sr+h, sc, dr, dc);
            for(String vpat:vpath){
                path.add("v"+h+vpat);
            }
        }
        //dogonal moves
        for(int h=1;h<=dr-sr&&h<=dc-sc;h++){
            ArrayList<String> dpath=get_all_maze_path(sr+h, sc+h, dr, dc);
            for(String dpat:dpath){
                path.add("d"+h+dpat);
            }
        }
        return path;
    }
    static ArrayList<String> maze_path(int sr,int sc,int dr,int dc){
        //get maze path in 2d array
        if(sr==dr&&sc==dc){
            ArrayList<String> h=new ArrayList<>();
            h.add("");
            return h;
        }
        ArrayList<String> hpath=new ArrayList<>();
        ArrayList<String> vpath=new ArrayList<>();
        if(sc<dc){
            hpath=maze_path(sr, sc+1, dr, dc);
        }
        if(sr<dr){
            vpath=maze_path(sr+1, sc, dr, dc);
        }
        ArrayList<String> path=new ArrayList<>();

        for(String hpat:hpath){
            path.add("h"+hpat);
        }
        for(String vpat:vpath){
            path.add("v"+vpat);
        }
        return path;
    }
    static ArrayList<String> stair_path(int n){
        if(n==0){
            ArrayList<String> k= new ArrayList<>();
            k.add("");
            return k;
        }else if(n<0){
            ArrayList<String> k= new ArrayList<>();
            return k;
        }

        ArrayList<String> path1=stair_path(n-1);
        ArrayList<String> path2=stair_path(n-2);
        ArrayList<String> path3=stair_path(n-3);

        ArrayList<String> rpath=new ArrayList<>();
        for(String path:path1){
            rpath.add(1+path);
        }
        for(String path:path2){
            rpath.add(2+path);
        }
        for(String path:path3){
            rpath.add(3+path);
        }
        return rpath;
    }
    //get pc start here
    static String[] code={"","abc","def","ghi","jkl","mno","pqrs","tu","vwx","yz",};
    static ArrayList<String> getkpc(String str){
        if(str.length()==0){
            ArrayList<String> bres=new ArrayList<>();
            bres.add("");
            return bres;
        }
        char ch=str.charAt(0);
        String ros=str.substring(1);

        ArrayList<String> rres=getkpc(ros);
        ArrayList<String> mres=new ArrayList<>();

        String codeforch=code[ch-'0'];
        for(int i=0;i<codeforch.length();i++){
            char chcode=codeforch.charAt(i);
            for(String rstr:rres){
                mres.add(chcode+rstr);
            }
        }
        return mres;
    }
    //get pc end here
    static ArrayList<String> get_subsequence(String str){
            //subsequence is differ from substring
            //output=[, a, b, ab, c, ac, bc, abc]
            if(str.length()==0){
                ArrayList<String> bres=new ArrayList<>();
                bres.add("");
                return bres;
            }
            char ch=str.charAt(0);
            String ros=str.substring(1);
            ArrayList<String> rres=get_subsequence(ros);

            ArrayList<String> mres=new ArrayList<>();
            for(String l:rres){
                mres.add(""+l);
                mres.add(ch+l);
            }
            return mres;
    }
    static int[] all_index(int[] arr,int data,int index,int arr_size){
        //return all index where data is present
        if(arr.length==index){
            return new int[arr_size];
        }
        if(arr[index]==data){
            int[] res=all_index(arr, data, index+1, arr_size+1);
            res[arr_size]=index;
            return res;
        }else{
            int[] res=all_index(arr, data, index+1, arr_size);
            return res;
        }
    }
    static int last_index(int[] arr,int index,int data){
        if(arr.length==index)return -1;

        int lindex=last_index(arr, index+1, data);
        if(lindex==-1){
            if(arr[index]==data){
                return index;
            }else{
                return -1;
            } 
        }else{
            return lindex;
        }
    }
    static int first_index(int[] arr,int index,int data){
        if(arr.length==0)return -1;
        if(index==arr.length)return -1;

        int findex=first_index(arr,index+1,data);

        if(arr[index]==data)return index;
        else return findex;
    }
    static int first_index2(int[] arr,int index,int data){
        //best approch
        if(arr.length==0)return -1;
        if(index==arr.length)return -1;

        if(arr[index]==data){
            return index;
        }
        else{
            int findex=first_index(arr,index+1,data);
            return findex;
        }
    }
    static int max_in_arr(int[] arr,int index){
        //max in arr using recursion
        if(index==arr.length-1)return arr[index];
        
        int c=max_in_arr(arr, index+1);
        if(c>arr[index])return c;
        else
        return arr[index];
    }
    static void display_array_rev(int[] arr,int index){
        if(index==arr.length)return;
        display_array_rev(arr, index+1);
        System.out.println(arr[index]);
    }
    static void display_array(int[] arr,int index){
        if(index==arr.length)return;
        System.out.println(arr[index]);
        display_array(arr, index+1);
    }
    static void tower_of_hanoi(int n,int d1,int d2,int d3){
        if(n==0)return;
        tower_of_hanoi(n-1, d1, d3, d2);
        System.out.println(n+"|"+d1+" "+d2);
        tower_of_hanoi(n-1, d3, d2, d1);
    }
    static void zigzag(int n){
        if(n==0)return;
        System.out.print(n);
        zigzag(n-1);
        System.out.print(n);
        zigzag(n-1);
        System.out.print(n);
    }
    static int power_liner(int x,int n){
        if(n==0)return 1;
        int xm1=power_liner(x, n-1);
        int xn=x*xm1;
        return xn;
    }
    static int fact(int n){
        if(n==1)return 1;
        int h=fact(n-1);
        int ans=n*h;
        return ans;
    }
    static void printd_i(int n){
        if(n==0)return;
        System.out.println(n);
        printd_i(n-1);
        System.out.println(n);
    }
    static void printincreasin(int n){
        if(n==0)return;
        printincreasin(n-1);
        System.out.println(n);
   }
    static void printdecreasing(int n){
       if(n==0)return;
       System.out.println(n);
       printdecreasing(n-1);
   }




}